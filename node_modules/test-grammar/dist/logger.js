"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = require("@sorg/log");
var colors = {
    bg: '#222'
};
exports.logger = new log_1.Logger({
    invalid: {
        styles: [
            { background: colors.bg, color: '#f22' },
            { background: colors.bg, color: '#fa0' },
            { background: colors.bg, color: '#ff0' }
        ],
        wrappers: [
            ['   [INVALID ', ']: '],
            ['', ' '],
            ['', ' ']
        ],
        customHandler: function (data) {
            var output = '';
            var length = 17;
            for (var i = 0; i < data.rawMessages.length; i++) {
                var msg = data.rawMessages[i];
                var con = log_1.converter(msg, { typeStyles: data.typeStyles });
                length += con.message.length;
                if (i === data.rawMessages.length - 1) {
                    length += i;
                    con.message += '  ';
                }
                output += log_1.styler(con, data.styles[i], data.wrappers[i]);
            }
            var line = ' '.repeat(length);
            output = log_1.styler(line, { background: colors.bg }, null) + "\n" + output + "\n" + log_1.styler(line, { background: colors.bg }, null) + "\n";
            return output;
        }
    },
    failed: {
        styles: [],
        wrappers: [],
        customHandler: function (data) {
            var lines = [];
            var longestLine = 27;
            var lineData = data.rawMessages[0];
            lineData.line = lineData.line.replace(/ /g, '·');
            var cName = log_1.converter(data.rawMessages[1], { typeStyles: data.typeStyles });
            var cLine = log_1.converter(data.rawMessages[2], { typeStyles: data.typeStyles });
            var cToken = log_1.converter(data.rawMessages[3], { typeStyles: data.typeStyles });
            var cExpected = log_1.converter(data.rawMessages[4], { typeStyles: data.typeStyles });
            var cReceived = log_1.converter(data.rawMessages[5], { typeStyles: data.typeStyles });
            cExpected.message = cExpected.message.replace(/,/g, ' ');
            cReceived.message = cReceived.message.replace(/,/g, ' ');
            lines.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            longestLine += cName.message.length;
            longestLine += cLine.message.length;
            longestLine += cToken.message.length;
            var l1t = {
                text: '',
                length: longestLine
            };
            l1t.text += log_1.styler("   [Failed]: ", { background: colors.bg, color: '#f00' }, null);
            l1t.text += log_1.styler(cName, { background: colors.bg, color: '#f24' }, null);
            l1t.text += log_1.styler(" Line:", { background: colors.bg, color: '#02a' }, null);
            l1t.text += log_1.styler(cLine, { background: colors.bg, color: '#06f' }, null);
            l1t.text += log_1.styler("Token:", { background: colors.bg, color: '#02a' }, null);
            l1t.text += log_1.styler(cToken, { background: colors.bg, color: '#06f' }, null);
            l1t.text += log_1.styler('  ', { background: colors.bg }, null);
            lines.push(l1t);
            lines.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            var l2l = 6;
            var lineStart = lineData.line.slice(0, lineData.token.startIndex);
            var lineMiddle = lineData.line.slice(lineData.token.startIndex, lineData.token.endIndex);
            var lineEnd = lineData.line.slice(lineData.token.endIndex);
            l2l += lineStart.length;
            l2l += lineMiddle.length;
            l2l += lineEnd.length;
            longestLine = Math.max(longestLine, l2l);
            var l2 = {
                text: '',
                length: l2l
            };
            l2.text += log_1.styler("      " + lineStart, { color: '#777', background: colors.bg }, null);
            l2.text += log_1.styler(lineMiddle, { color: '#fff', background: colors.bg }, null);
            l2.text += log_1.styler(lineEnd, { color: '#777', background: colors.bg }, null);
            lines.push(l2);
            var l3l = 19 + cExpected.message.length;
            longestLine = Math.max(longestLine, l3l);
            var l3 = {
                text: '',
                length: l3l
            };
            lines.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            l3.text += log_1.styler("      Expected: ", { background: colors.bg, color: '#2a2' }, null);
            l3.text += log_1.styler(cExpected.message + "   ", { background: colors.bg, color: '#0e0' }, null);
            lines.push(l3);
            var l4l = 19 + cReceived.message.length;
            longestLine = Math.max(longestLine, l4l);
            var l4 = {
                text: '',
                length: l4l
            };
            lines.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            l4.text += log_1.styler("      Received: ", { background: colors.bg, color: '#a22' }, null);
            l4.text += log_1.styler(cReceived.message + "   ", { background: colors.bg, color: '#e00' }, null);
            lines.push(l4);
            lines.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            return MapLines(lines, longestLine, log_1.styler);
        }
    },
    passed: {
        styles: [],
        wrappers: [],
        customHandler: function (data) {
            var length = 30;
            var cName = log_1.converter(data.rawMessages[1], { typeStyles: data.typeStyles });
            length += cName.message.length;
            var extended = data.rawMessages[0] !== null;
            if (extended) {
                var lineData = data.rawMessages[0];
                lineData.line = lineData.line.replace(/ /g, '·');
                // tslint:disable-next-line: prefer-const
                var cLine = log_1.converter(data.rawMessages[2], { typeStyles: data.typeStyles });
                // tslint:disable-next-line: prefer-const
                var cToken = log_1.converter(data.rawMessages[3], { typeStyles: data.typeStyles });
                // tslint:disable-next-line: prefer-const
                var lineStart = lineData.line.slice(0, lineData.token.startIndex);
                // tslint:disable-next-line: prefer-const
                var lineMiddle = lineData.line.slice(lineData.token.startIndex, lineData.token.endIndex);
                // tslint:disable-next-line: prefer-const
                var lineEnd = lineData.line.slice(lineData.token.endIndex);
                length += cLine.message.length;
                length += cToken.message.length;
                length += lineStart.length;
                length += lineMiddle.length;
                length += lineEnd.length;
            }
            else {
                length -= 14;
            }
            var output = log_1.styler(getSpace(length) + "\n", { background: colors.bg }, null);
            output += log_1.styler("   [Passed]: ", { background: colors.bg, color: '#0f0' }, null);
            output += log_1.styler(cName, { background: colors.bg, color: extended ? '#2c8' : '#c2f' }, null);
            if (extended) {
                output += log_1.styler(" Line:", { background: colors.bg, color: '#02a' }, null);
                // @ts-ignore
                output += log_1.styler(cLine, { background: colors.bg, color: '#06f' }, null);
                output += log_1.styler("Token:", { background: colors.bg, color: '#02a' }, null);
                // @ts-ignore
                output += log_1.styler(cToken, { background: colors.bg, color: '#06f' }, null);
                output += log_1.styler('  ', { background: colors.bg }, null);
                // @ts-ignore
                output += log_1.styler(lineStart, { color: '#777', background: colors.bg }, null);
                // @ts-ignore
                output += log_1.styler(lineMiddle, { color: '#fff', background: colors.bg }, null);
                // @ts-ignore
                output += log_1.styler(lineEnd + "   \n", { color: '#777', background: colors.bg }, null);
            }
            else {
                output += log_1.styler(getSpace(length - (13 + cName.message.length)) + "\n", { background: colors.bg }, null);
            }
            output += log_1.styler(getSpace(length) + "\n", { background: colors.bg }, null);
            return output;
        }
    },
    stats: {
        styles: [],
        customHandler: function (data) {
            var stats = data.rawMessages[0];
            var LINES = [];
            var longestLine = 0;
            var maxWidth = Math.max(("" + stats.cases).length, ("" + stats.errors).length, ("" + stats.failedCases).length, ("" + stats.failedLines).length, ("" + stats.failedTokens).length, ("" + stats.lines).length, ("" + stats.passedCases).length, ("" + stats.passedLines).length, ("" + stats.passedTokens).length, ("" + stats.tokens).length);
            var cases = AddPadding(stats.cases, maxWidth, ("" + stats.cases).length);
            var errors = AddPadding(stats.errors, maxWidth, ("" + stats.errors).length);
            var failedCases = AddPadding(stats.failedCases, maxWidth, ("" + stats.failedCases).length);
            var failedLines = AddPadding(stats.failedLines, maxWidth, ("" + stats.failedLines).length);
            var failedTokens = AddPadding(stats.failedTokens, maxWidth, ("" + stats.failedTokens).length);
            var lines = AddPadding(stats.lines, maxWidth, ("" + stats.lines).length);
            var passedCases = AddPadding(stats.passedCases, maxWidth, ("" + stats.passedCases).length);
            var passedLines = AddPadding(stats.passedLines, maxWidth, ("" + stats.passedLines).length);
            var passedTokens = AddPadding(stats.passedTokens, maxWidth, ("" + stats.passedTokens).length);
            var tokens = AddPadding(stats.tokens, maxWidth, ("" + stats.tokens).length);
            LINES.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            var l1l = 39 + ("" + cases + errors + failedCases + errors).length;
            longestLine = Math.max(longestLine, l1l);
            var l1 = {
                text: '',
                length: l1l
            };
            l1.text += log_1.styler("  Cases:  " + cases, { color: '#82f', background: colors.bg }, null);
            l1.text += log_1.styler(" Passed: " + passedCases, { color: '#2f2', background: colors.bg }, null);
            l1.text += log_1.styler(" Failed: " + failedCases, { color: stats.failedCases === 0 ? '#0af' : '#f00', background: colors.bg }, null);
            l1.text += log_1.styler(" Errors: " + errors + "  ", { color: stats.errors === 0 ? '#855' : '#f00', background: colors.bg }, null);
            LINES.push(l1);
            LINES.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            var l2l = 28 + ("" + lines + failedLines + passedLines).length;
            longestLine = Math.max(longestLine, l2l);
            var l2 = {
                text: '',
                length: l2l
            };
            l2.text += log_1.styler("  Lines:  " + lines, { color: '#82f', background: colors.bg }, null);
            l2.text += log_1.styler(" Passed: " + passedLines, { color: '#2f2', background: colors.bg }, null);
            l2.text += log_1.styler(" Failed: " + failedLines, { color: stats.failedLines === 0 ? '#0af' : '#f00', background: colors.bg }, null);
            LINES.push(l2);
            LINES.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            var l3l = 28 + ("" + tokens + failedTokens + passedTokens).length;
            longestLine = Math.max(longestLine, l3l);
            var l3 = {
                text: '',
                length: l3l
            };
            l3.text += log_1.styler("  Tokens: " + tokens, { color: '#82f', background: colors.bg }, null);
            l3.text += log_1.styler(" Passed: " + passedTokens, { color: '#2f2', background: colors.bg }, null);
            l3.text += log_1.styler(" Failed: " + failedTokens, { color: stats.failedTokens === 0 ? '#0af' : '#f00', background: colors.bg }, null);
            LINES.push(l3);
            LINES.push({ text: 'EMPTY_LINE_TEST_GRAMMAR' });
            var success = stats.failedCases === 0 && stats.errors === 0;
            var EndingText = success ? 'Success' : 'Failed ';
            var subEndText = EndingText.length;
            return (MapLines(LINES, longestLine, log_1.styler) +
                log_1.styler(getSpace(Math.round((longestLine - subEndText) / 2)) + "\u001B[1m" + EndingText + getSpace(Math.round((longestLine - subEndText - (longestLine % 2 === 1 ? 0 : 1)) / 2)) + "\n" + getSpace(longestLine), { color: success ? '#0f0' : '#f00', background: '#111' }, null));
        }
    }
});
function getSpace(length) {
    if (Math.sign(length) === -1) {
        return '';
    }
    return ' '.repeat(length);
}
function MapLines(lines, longestLine, styler) {
    return lines
        .map(function (v) {
        if (!v.length) {
            v.text = styler(getSpace(longestLine) + "\n", { background: colors.bg }, null);
        }
        else if (v.length < longestLine) {
            v.text += styler(getSpace(longestLine - v.length) + "\n", { background: colors.bg }, null);
        }
        else {
            v.text += '\n';
        }
        return v.text;
    })
        .join('');
}
function AddPadding(input, maxWidth, width) {
    return "" + input + getSpace(maxWidth - width);
}
